# title: "Дисперсионный анализ, часть 2"
# subtitle: "Математические методы в зоологии с использованием R"
# author: "Марина Варфоломеева"

# ## Пример: Возраст и способы запомниания ########
#
# Какие способы запоминания информации лучше
# работают для молодых и для пожилых? (Eysenck,
# 1974)
#
# Факторы:
#
# - `Age` - Возраст:
#     - `Younger` - 50 молодых
#     - `Older` - 50 пожилых (55-65 лет)
# - `Process` - тип активности:
#     - `Counting` - посчитать число букв
#     - `Rhyming` - придумать рифму к слову
#     - `Adjective` - придумать прилагательное
#     - `Imagery` - представить образ
#     - `Intentional` - запомнить слово
#
# Зависимая переменная - `Words` - сколько вспомнили слов


# ## Открываем данные
memory <- read.table(file = "data/eysenck.csv", header = TRUE, sep = "\t")
# Все ли правильно открылось?
str(memory) # Структура данных
head(memory, 2) # Первые несколько строк файла

# Есть ли пропущенные значения
# (особенно, в переменных, которые нас интересуют)?
colSums(is.na(memory))
# Каков объем выборки?
nrow(memory) # всего
table(memory$Age, memory$Process) # в группах


# ## Задание 1 -----------------------------------

# Дополните код, чтобы построить график, на
# котором приведено среднее число слов (`Words`)
# для каждого возраста (`Age`) и способа
# запоминания (`Process`).

library()
theme_set()
ggplot(data = , aes()) +
  stat_summary(geom = '', fun.data = ,
               position = position_dodge(width = 0.5))





#### Порядок уровней в факторах ##################

# Давайте изменим порядок уровней в факторе
# `memory$Process` так, чтобы он соответствовал
# возрастанию средних значений `memory$Words`
# "старый" порядок уровней
levels(memory$Process)
# переставляем уровни в порядке следования средних
# значений memory$Words
memory$Process <- reorder(x = memory$Process, X = memory$Words, FUN = mean)
# "новый" порядок уровней стал таким
levels(memory$Process)

# ## График с "правильным" порядком уровней






#### Двухфакторный дисперсионный анализ ###########

# ## Задаем модель со взаимодействием в R
# Взаимодействие обозначается `:` --- двоеточием
# Если есть факторы A и B, то их взаимодействие A:B
# Два варианта написания формулы модели со взаимодействием:
# Y ~ A + B + A:B
# Y ~ A*B
# III тип сумм квадратов
# тип кодирования для факторов
# contrasts = list(Age = contr.sum, Process = contr.sum)


#### Задание 2 -----------------------------------

# Дополните этот код, чтобы подобрать линейную
# модель со взаимодействием факторов, в которой
# используется нужный тип кодирования для
# факторов: `contrasts = list(Age = contr.sum,
# Process = contr.sum)`

mem_mod <- lm(formula = , data = ,
contrasts = list(Age = contr.sum, Process = contr.sum))


#### Задание 3 -----------------------------------
#
# Проверьте условия применимости дисперсионного анализа
#
# - Есть ли гомогенность дисперсий?
# - Не видно ли паттернов в остатках?
# - Нормальное ли у остатков распределение?

# Данные для анализа остатков
mem_diag <- fortify()
# График расстояния Кука
ggplot(data = , aes(x = 1:nrow(   ), y = )) +
  geom_
# График остатков от предсказанных значений
ggplot(data = , aes()) +
  geom_
# Квантильный график остатков
qqPlot




#### Результаты дисперсионного анализа ############
library(car)
Anova(mem_mod, type = 3)


#### Пост хок тест для взаимодействия факторов

# ## Задание 4 -----------------------------------
#
# Дополните этот код, чтобы посчитать пост хок
# тест Тьюки по взаимодействию факторов

# Создаем переменную-взаимодействие
memory$AgeProc <- interaction(memory$Age, memory$)
# Подбираем линейную модель без свободного члена
cell_means <- (Words ~ AgeProc - 1, data = )
# Делаем пост хок тест для этой модели
library(multcomp)
memory_tukey <- glht(model = ,
                     linfct = mcp())
summary(memory_tukey)





#### График результатов дисперсионного анализа ######

# Данные для графиков
process <- levels(memory$Process)
fprocess <- factor(process, levels = process)
MyData <- expand.grid(Age = levels(memory$Age),
                      Process = fprocess)
MyData <- data.frame(MyData,
  predict(mem_mod, newdata = MyData,
          interval = "confidence"))
head(MyData)


#### Задание 5 -----------------------------------
#
# Видоизмените код, чтобы построить график
# результатов

pos <- position_dodge(width = 0.3)
gg_pointp <- ggplot() +
  geom_ (aes(), size = 3, position = pos) +
  geom_ (aes(ymin = , ymax = ), width = 0.1, position = pos)
gg_pointp


# ## Приводим график в приличный вид
gg_final <- gg_pointp +
  scale_colour_brewer(name = "Возраст", palette = "Dark2",
                      labels = c("Пожилые", "Молодые")) +
  scale_shape_discrete(name = "Возраст",
                       labels = c("Пожилые", "Молодые")) +
  scale_x_discrete(name = "Процесс",
                   labels = c("Счет", "Рифма", "Прилагательное",
                              "Образ", "Запоминание")) +
  labs(y = "Число слов")

gg_final


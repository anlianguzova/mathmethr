---
title: Знакомство с R (молниеносное и поверхностное).
---

# Загружаем, устанавливаем...

Cобственно, сам [R](https://cran.r-project.org/)

[RStudio](https://www.rstudio.com) - среда для разработки (IDE) на R

Онлайн IDE для R --- на тот случай, если у вас не установлен R:

- https://rstudio.cloud
- https://www.tutorialspoint.com/r_terminal_online.php
- http://rextester.com/l/r_online_compiler

Упражнения для начинающих:

- https://www.datacamp.com/courses


# Комментарии

Комментарии в текстах программ обозначаются символом #

```{r}
# это комментарии, они не будут выполняться
```

# Полезные клавиатурные сокращения в RStudio

- `Ctrl + Shift + C` - закомментировать/раскомментировать выделенный фрагмент кода
- `Ctrl + Enter` - отправляет активную строку из текстового редактора в консоль, а если выделить несколько строк, то будет выполнен этот фрагмент кода.
- `Tab` или `Ctrl + Space` - нажмите после того как начали набирать название функции или переменной, и появится список автоподстановки. Это помогает печатать код быстро и с меньшим количеством ошибок.

<!-- # Устанавливаем рабочую директорию -->

<!-- Есть несколько способов установки пути к рабочей директории: -->

<!-- 1. Выберите в меню `Session -> Set working Directory... -> To Source File Location` (Если вы уже сохранили код). -->
<!-- 2. На вкладке `Files` в одной из рабочих областей RStudio выберите многоточие `...` -> в открывшемся системном диалоге выбора файлов найдите директорию, в которой лежит ваш код и нажмите OK -->
<!-- 3. Можно вручную прописать путь к рабочей директории в кавычках в качестве аргумента функции `setwd()` -->

<!-- ```{r eval=FALSE} -->
<!-- setwd("~/lect-linmodr") -->
<!-- ``` -->

# Как получить помощь

1. В RStudio можно поставить курсор на слово `setwd` и нажать `F1`
2. Перед названием функции можно напечатать знак вопроса и выполнить эту строку
`?setwd`
3. Можно воспользоваться функцией `help()`

```{r eval=FALSE}
help("setwd")
```

# R как калькулятор, математические операции

```{r}
2+2
1024/2
1:10
34*4
2^4
sqrt(27)
```

# Переменные

Оператор присваивания это символ стрелочки `<-`. Он работает справа налево, это значит, что значение выражения в его правой части присваивается объекту в левой части.

Переменные - это такие контейнеры, в которые можно положить разные данные и даже функции.


Имена переменных могут содержать латинские буквы обоих регистров, символы точки . и подчеркивания _ , а так же цифры. Имена переменных должны начинаться с латинских букв. Создавайте понятные и "говорящие" имена переменных.

```{r}
var_1 <- 1024 / 2
1238 * 3 -> var_2
var_2
```

Как выбрать название переменной?

- `a` - плохо, и даже `b`, `с`, или `х`. Но в некоторых случаях допустимо:)
- `var1` - плохо, но уже лучше
- `var_1` - плохо, но уже лучше
- `shelllength` - говорящее, но плохо читается
- `shell_length`, `wing_colour` или `leg_num` - хорошие говорящие и читабельные названия

# Векторы - одномерные структуры данных

Данные в R можно хранить в виде разных объектов.

В результате выполнения следующих команд числа. Одно выражение - одно значение.

```{r}
23
sqrt(25)
```

На самом деле, эти величины - просто векторы единичной длины

_Векторы_ - один объект, внутри которого несколько значений.

### Некоторые способы создания векторов:

- Оператор: используется для создания целочисленных векторов, где значения следуют одно за другим без пропусков

```{r}
1:10 # от одного до 10
-5:3 # от -5 до 3
```

- Функция `seq()` создает последовательности из чисел

```{r}
seq(from = 1, to = 5, by = 0.5)
```

- Функция `c()` - от англ. concatenate. Следите, чтобы было английское си, а не русское эс:).

```{r eval=FALSE}
?c # посмотрите хелп к функции
```

Функция `c` принимает несколько (произвольное количество) аргументов, разделенных запятыми. Она собирает из них вектор.

```{r}
c(2, 4, 6)
c(-9.3, 0, 2.17, 21.3)
```

Векторы можно хранить в переменных для последующего использования

```{r}
vect_num <- -11:12 # численный вектор от -11 до 12 сохранен в переменной vect_num
vect_num_1 <- c(1.3, 1.7, 1.2, 0.9, 1.6, 1.4) # численный вектор, сохранен в переменной vect_num_1
```

### Адресация внутри векторов

При помощи оператора `[]`, мужно обратится к некоторым элементам вектора. 
В квадратных скобках вам нужно указать один или несколько порядковых номеров элементов

```{r}
vect_num[1] # первый элемент в векторе vect_num
vect_num[10] # 10-й элемент
vect_num[22]
```

Если вам нужно несколько элементов, то их нужно передать квадратным скобкам в виде вектора. Например, нам нужны элементы с 3 по 5. Вот вектор, который содержит значения 3, 4 и 5.

```{r}
3:5
```

Если мы его напишем в квадратных скобках, то добудем элементы с такими порядковыми номерами

```{r}
vect_num[3:5]
```

Аналогично, если вам нужны элементы не подряд, то передайте вектор с номерами элементов, который вы создали при помощи функции c()
c(2, 4, 6) # это вектор содержащий 2, 4 и 6, поэтому

```{r}
vect_num[c(2, 4, 6)] # возвращает 2-й, 4-й и 6-й элементы
vect_num[c(1, 10, 20)] # возвращает 1-й, 10-й и 20-й элементы
```

Вектор - одномерный объект. У его элементов только один порядковый номер (индекс). Поэтому при обращении к элементам вектора нужно указывать только одно число или один вектор с адресами.

Правильно:

```{r}
vect_num[c(1, 2, 5)] # возвращает 1-й, 3-й и 5-й элементы
```

Но R выдаст ошибку, если при обращении к вектору, вы не создавали вектор, а просто перечислили номера элементов через запятую.

```{r eval=FALSE}
vect_num[1, 3, 5] # ошибка
vect_num[15, 9, 1] # ошибка
```
```{r}
vect_num[c(15, 9, 1)] # правильно
```


При помощи функции c() можно объединять несколько векторов в один вектор

```{r}
c(1, 1, 5:9)
c(vect_num, vect_num)
c(100, vect_num)
```

Добываем 1, 3, 5 и с 22 по 24 элементы

```{r}
vect_num[c(1, 3, 5, 22:24)]
```

# Типы данных в R

## Числовые данные

Уже видели в прошлом разделе.

## Текстовые данные

Каждый текстовый элемент (говорят "строка" - string или character) должен быть окружен кавычками - двойными или одинарными.

```{r}
"это текст"
'это тоже текст'
```

Текстовые значения можно объединять в вектора.

Это текстовый вектор

```{r}
rainbow <- c("red", "orange", "yellow", "green", "blue", "violet")
rainbow # весь вектор
```

Добываем первый и последний элементы

В данном случае я точно знаю, что их 6, мне нужны 1 и 6.

```{r}
rainbow[c(1, 6)]
```

Добываем элементы с 3 по 6

Если у вас вдруг слишком короткий вектор в этом задании, то можно склеить новый из двух

```{r}
double_rainbow <- c(rainbow, rainbow)
double_rainbow
rainbow[3:6] # элементы с 3 по 6
```

## Логические данные

```{r}
TRUE # истина
FALSE # ложь
```

Для ленивых - можно сокращать первыми заглавными буквами. **Но лучше так не делать**, чтобы читать программы было легче.

```{r}
c(T, T, T, T, F, F, T, T)
```

Логический вектор

```{r}
c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)
```

Еще логический вектор

```{r}
short_logical_vector <- c(FALSE, TRUE)
```

Создаем длинный логический вектор.

Чтобы создавать длинные вектора из повторяющихся элементов, можно использовать функцию rep()

```
?rep
```

```{r}
rep(x = 1, times = 3) # 1 повторяется 3 раза
rep(x = "red", times = 5) # "red" повторяется 5 раз
rep(x = TRUE, times = 2) # TRUE повторяется 2 раза
```

В R названия аргументов функций можно не указывать, если вы используете аргументы в том же порядке, что прописан в help к этой функции.

```{r}
rep(TRUE, 5) # TRUE повторяется 5 раз, аргументы без названий
```

Создаем логический вектор, где TRUE повторяется 3 раза, FALSE 3 раза и TRUE 4 раза. Результат сохраняем в переменной vect_log

```{r}
vect_log <- c(rep(TRUE, 3), rep(FALSE, 3), rep(TRUE, 4))
vect_log
```

### Применение логических векторов для фильтрации данных

Логические векторы создаются при проверке выполнения каких либо условий, заданных при помощи логических операторов (`>`, `<`, `==`, `!=`, `>=`, `<=`, `!`, `&`, `|`). Такие векторы можно использовать для фильтрации данных

Вспомните, у нас был вот такой текстовый вектор

```{r}
double_rainbow
```

Задача 1. Допустим, мы хотим из этого вектора извлечь только желтый цвет.

Мы можем создать логический вектор, в котором TRUE будет только для 3-го и 9-го элементов
```{r}
f_yellow <- double_rainbow == "yellow"
f_yellow
```

Этот логический вектор-фильтр мы можем использовать для извлечения данных из `double_rainbow`

```{r}
double_rainbow[f_yellow]
```

Задача 2. Допустим, мы хотим извлечь из double_rainbow желтый и синий Желтый фильтр у нас уже есть, поэтому мы создадим фильтр для синего.

```{r}
f_blue <- double_rainbow == "blue"
```

Выражение "желтый или синий" можно записать при помощи логического "или" (`|`)

```{r}
f_yellow | f_blue
```

Задача решена, мы извлекли желтый и синий цвета.

```{r}
double_rainbow[f_yellow | f_blue]
```

То же самое можно было бы записать короче.

В одну строку --- совершенно нечитабельно:

```{r}
double_rainbow[double_rainbow == "yellow" | double_rainbow == "blue"]
```

Фильтр отдельно --- читается лучше:

```{r}
f_colours <- double_rainbow == "yellow" | double_rainbow == "blue"
double_rainbow[f_colours]
```

У нас был числовой вектор 

```{r}
vect_num
```

Задача 3. Давайте извлечем из числового вектора `vect_num` только значения больше 0

```{r}
vect_num[vect_num > 0]
```

Задача 4. Давайте извлечем из вектора `vect_num` все числа, которые либо меньше или равны -8, либо больше или равны 8

```{r}
f_5_8 <- (vect_num <= -8) | (vect_num >= 8)
vect_num[f_5_8]
```


## Факторы

Факторы - это способ хранения дискретных (=категориальных данных). Например, если вы поймали 10 улиток и посмотрели их цвет. У большого количества улиток небольшое счетное количество возможных цветов.

```{r}
snail_colours <- c("red", "green", "green", "green", "yellow", "yellow", "yellow", "yellow")
snail_colours # это текстовый вектор.
```

Но цвет "желтый" обозначает одно и то же для каждой из улиток. Поэтому в целях экономии места можно записать цвета этих улиток в виде вектора, в котором численным значениям будут сопоставлены "этикетки" (называются "уровни" - levels) - названия цветов. Мы можем создать "фактор" цвет улиток.

```{r}
factor(snail_colours)
```

уровни этого фактора

- 1 - green,
- 2 - red,
- 3 - yellow

По умолчанию, R назначает порядок уровней по алфавиту. Можно изменить порядок (см. `help("factor")`). Нам это пригодится позже

```{r}
double_rainbow # текстовый вектор
```

Создаем фактор из текстового вектора и складываем его в переменную

```{r}
f_double_rainbow <- factor(double_rainbow)
```

## Как узнать, что за данные хранятся в переменной?

Чтобы узнать, что за данные хранятся в переменной, используйте функцию `class()`

```{r}
class(f_double_rainbow)
class(vect_log)
class(vect_num)
class(rainbow)
```


# Встроенные константы в R

Встроенные константы в R: NA, NULL, NAN, Inf

- NA - англ "not available". Когда объект был, но его свойство не измерили или не записали.
- NULL - пусто - просто ничего нет
- NaN - "not a number"
- Inf - "infinity" - бесконечность

Вот текстовый вектор с пропущенным значением

```{r}
rainbow_1 <- c("red", "orange", NA, "green", "blue", "violet")
```

Кстати, если попросили добыть из вектора номер элемента, которого там точно нет, то R выдаст NA, потому, что такого элемента нет

```{r}
rainbow_1[198]
```

Поэкспериментируем с векторами. Проверим, как работают арифметические операции

```{r}
vect_num + 2
vect_num * 2
vect_num * (-2)
vect_num ^2
```

Теперь посмотрим на встроенные константы в действии.

Создаем новый вектор для экспериментов

```{r}
NAs_NANs <- c(1, 3, NA, 7, 0, 22:24)
```

Вот так он выглядит

```{r}
NAs_NANs
```

Что произойдет с NA?

```{r}
NAs_NANs + 2 # останется NA
NAs_NANs * 0 # останется NA
NAs_NANs / 0  # останется NA
```

Но в последнем случае вы увидите 

- Inf при делении чисел на ноль
- NaN при делении нуля на ноль

NaN получится, если взять корень из отрицательного числа

```{r}
sqrt(-1)
```

# Функции в R

Вы уже видели массу функций, их легко узнать по скобкам после ключевого слова. Познакомимся еще с несколькими и научимся писать пользовательские функции. Пользовательские функции позволяют автоматизировать повторяющиеся действия и делают код легко читаемым.

Вот наш вектор

```{r}
NAs_NANs
```

Длину вектора можно вычислить при помощи функции `length()`

```{r}
length(NAs_NANs)
```

Сумму элементов вектора при помощи функции `sum()`

```{r}
sum(NAs_NANs)
```

Упс! Почему-то получилось `NA`

Чтобы узнать, почему и как это исправить - посмотрите в `help("sum")`. 
Выяснится, что у функции `sum()` есть аргумент `na.rm`, который по умолчанию принимает значение `FALSE`, то есть `NA` не учитываются при подсчете суммы.

Если мы передадим функции `sum` аргумент `na.rm = TRUE`, то получится правильная сумма

```{r}
sum(NAs_NANs, na.rm = TRUE)
```

Та же история с функцией `mean`

```{r}
mean(NAs_NANs, na.rm = TRUE)
```

Попробуем написать пользовательскую функцию `mmean()`, которая будет по умолчанию считать среднее значение элементов в векторе с учетом пропущенных значений (`NA`)

```{r}
mmean <- function(x){
  mean(x, na.rm = TRUE)
  }
```

В этом коде:
- mmean - переменная, название функции. В эту переменную мы складываем функцию, которую создает функция `function()`
- `function()` - функция, которая делает функции. В скобках перечисляются аргументы (названия переменных, которые мы передаем в функцию, чтобы она что-то сделала с ними)
- `{ }` - в фигурных скобках тело функции - последовательность действий, которую нужно сделать с аргументами

У больших функций бывает еще инструкция `return()`, которая сообщает, что именно должна возвращать наша функция. Вот как выглядела бы наша функция с этой инструкцией

```{r}
mmean <- function(x){
  res <- mean(x, na.rm = TRUE)
  return(res)
}
```

Проверим нашу функцию при помощи встроенной функции

```{r}
mean(vect_num, na.rm = TRUE)
mmean(vect_num)
```

Работает

# Датафреймы - двумерные структуры данных

Датафрейм - один из способов хранения табличных данных в R. Создадим датафрейм.

Для этого, для начала, создадим векторы с данными для переменных.

```{r}
len <- 1:9 # числовой
col <- c(rep("green", 4), rep("red", 5)) # текстовый
wid <- seq(from = 2, by = 2, to = 18) # числовой
```

Теперь сложим эти векторы в датафрейм

```{r}
my_worms <- data.frame(Length = len, Width = wid, Colour = col)
```

Можно проверить, действительно мы создали объект класса data.frame
```{r}
class(my_worms) # смотрим, действительно датафрейм
```

Содержимое датафрейма можно просмотреть несколькими способами
```{r}
my_worms # печать датафрейма
View(my_worms) # просмотр в RStudio
head(my_worms)
tail(my_worms)
# fix(my_worms) # ручное редактирование. осторожно! избегайте его использовать, никаких документов о нем не останется
```

## Адресация внутри датафреймов

Вывод столбца-переменной при помощи оператора $ и имени переменной

```{r}
my_worms$Length
my_worms$Width
```

У каждой ячейки в датафрейме есть координаты вида [строка, столбец]

```{r}
my_worms[2, 3] # вторая строка в 3 столбце
my_worms[2, ] # вторая строка целиком
my_worms[1:9, 2] # строки с 1 по 9 во втором столбце
my_worms[, 2] # второй столбец целиком
```

# Визуализация данных

## Базовые графики

Скаттерплот (точечный график) --- по оси х и y непрерывные числовые величины
```{r p-scatter}
plot(x = my_worms$Width, y = my_worms$Length)
```


Боксплот --- по оси х дискретная величина, по оси y  значение непрерывной величины. Черта - медиана, коробка - 25 и 75 персентили, усы - либо размах варьирования, либо 1.5 интерквартильных расстояния (1.5 высоты коробки), если есть "выбросы".

```{r p-box}
plot(x = my_worms$Colour, y = my_worms$Length)
```

Для настройки внешнего вида см graphical parameters в help

На самом деле, мы не будем пользоваться этой системой графики, но об этом в следующих сериях

## Графики из пакета ggplot2

В R есть более удобный (но, может быть, более многословный) пакет для рисования графиков --- ggplot2. 
Чтобы использовать функции из пакета ggplot2, нужно его сначала установить.

Установка пакета в локальную библиотеку делается один раз. Поэтому строку с `install.packages()` не нужно включать в финальную версию кода.
```{r}
install.packages('ggplot2')
```

В текущей сессии работы в R пакет нужно активировать перед использованием. Когда вы в следующий раз начнете работать с R, нужные пакеты придется снова активировать. Поэтому строки с загрузкой пакетов при помощи `library()` обязательно должны остаться в финальной версии кода.

```{r}
library(ggplot2)
```

Нарисуем те же самые графики при помощи пакета ggplot2.

```{r gg-scatter-box}
ggplot(data = my_worms) +
  geom_point(aes(x = Width, y = Length))

ggplot(data = my_worms) +
  geom_boxplot(aes(x = Colour, y = Length))
```


Добавляем для точек эстетику цвет (colour) из переменной Colour

```{r gg-colour}
ggplot(data = my_worms) +
  geom_point(aes(x = Width, y = Length, colour = Colour))
```


Графики можно сохранять в переменных, и использовать потом

```{r}
gg <- ggplot(data = my_worms) +
  geom_point(aes(x = Width, y = Length, colour = Colour))
```

Чтобы вывести график, нужно напечатать название переменной.
```{r gg-saved}
gg

```

Можно менять темы оформления графика. 
Если тема нужна только один раз, то прибавляем ее к графику

```{r gg-themes}
gg + theme_dark()
gg + theme_light()
gg + theme_classic()
```

Можно установить нужную тему до конца сессии.
```{r gg-theme-set}
theme_set(theme_bw())
gg
```

Подписи осей и легенд задает функция labs()

```{r gg-labs}
gg + labs(x = "Ширина", y = "Длина", colour = "Цвет")
```

Графики можно делить на фасетки при помощи facet_wrap или facet_grid

```{r gg-facets}
gg + facet_wrap(~Colour, nrow = 1)
```

Чтобы изменить подписи цветов, нужно изменить уровни соотв. фактора.

```{r gg-translate-captions}
my_worms$col_rus <- factor(my_worms$Colour, levels = c("green", "red"), labels = c("Зеленый", "Красный"))
ggplot(data = my_worms) +
  geom_point(aes(x = Width, y = Length, colour = col_rus)) +
  labs(x = "Ширина", y = "Длина", colour = "Цвет") +
  facet_wrap(~col_rus, nrow = 1)
```


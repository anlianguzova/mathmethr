<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Ординация и классификация с использованием мер сходства-различия</title>
    <meta charset="utf-8" />
    <meta name="author" content="Марина Варфоломеева" />
    <meta name="author" content="Анастасия Лянгузова" />
    <script src="libs/header-attrs-2.25/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/tamu-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/ninjutsu.css" rel="stylesheet" />
    <link href="libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view-0.2.6/tile-view.js"></script>
    <script src="libs/fabric-4.3.1/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble-0.0.1/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble-0.0.1/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30,"palette":[]}) })</script>
    <script src="libs/mark.js-8.11.1/mark.min.js"></script>
    <link href="libs/xaringanExtra-search-0.0.1/search.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-search-0.0.1/search.js"></script>
    <script>window.addEventListener('load', function() { window.xeSearch = new RemarkSearch({"position":"bottom-left","caseSensitive":false,"showIcon":false,"autoSearch":true}) })</script>
    <script src="libs/xaringanExtra-progressBar-0.0.1/progress-bar.js"></script>
    <script src="libs/freezeframe-5.0.2/freezeframe.min.js"></script>
    <script src="libs/xaringanExtra-freezeframe-0.0.1/freezeframe-init.js"></script>
    <script id="xaringanExtra-freezeframe-options" type="application/json">{"selector":"img[src$=\"gif\"]","trigger":"click","overlay":false,"responsive":true,"warnings":true}</script>
    <link href="libs/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <script src="libs/htmlwidgets-1.6.2/htmlwidgets.js"></script>
    <script src="libs/viz-1.8.2/viz.js"></script>
    <link href="libs/DiagrammeR-styles-0.2/styles.css" rel="stylesheet" />
    <script src="libs/grViz-binding-1.0.10/grViz.js"></script>
    <!-- https://github.com/fnaufel/xaringan-smartify-->
    <script
    			  src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
    			  integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8="
    			  crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/fnaufel/xaringan-smartify/smartify.min.js"></script>
    <link rel="stylesheet" href="assets/xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="assets/xaringan.css" type="text/css" />
    <link rel="stylesheet" href="assets/scrollable.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: middle, left, inverse, title-slide

.title[
# Ординация и классификация с использованием мер сходства-различия
]
.subtitle[
## Математические модели в зоологии
]
.author[
### Марина Варфоломеева
]
.author[
### Анастасия Лянгузова
]

---




class: middle, center, inverse

## Меры сходства и различия, ординация, классификация

---

### Вы сможете

- Выбирать подходящий для данных коэффициент сходства/различия
- Представлять многомерные данные в меньшем числе измерений при помощи неметрического многомерного шкалирования
- Строить дендрограммы при помощи подходящего метода аггрегации

---

class: middle, center, inverse

## Коэффициенты сходства и различия

---

## Коэффициенты сходства и различия

.pull-left[
**Различия (dissimilarities)**

`\(d \ge 0\)`

<div class="grViz html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-0934b6513640da994bdb" style="width:324px;height:36px;"></div>
<script type="application/json" data-for="htmlwidget-0934b6513640da994bdb">{"x":{"diagram":"digraph symmetry {\n\n  # a \"graph\" statement\n  graph [overlap = false, fontsize = 10, rankdir = LR]\n\n  # several \"node\" statements\n  node [shape = circle,\n        fixedsize = true,\n        width = 0.5,\n        style = filled,\n        color = grey]\n  node [fillcolor = PowderBlue]\n  A; B\n\n  # several \"edge\" statements\n  A->B [dir = \"both\"]\n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>

]

.pull-right[
**Сходства (similarities)**

`\(0 \le S \le 1\)` или `\(-1 \le S \le 1\)`

<div class="grViz html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-cb03b1e3b4842a20da31" style="width:324px;height:36px;"></div>
<script type="application/json" data-for="htmlwidget-cb03b1e3b4842a20da31">{"x":{"diagram":"digraph symmetry {\n\n  # a \"graph\" statement\n  graph [overlap = false, fontsize = 10, rankdir = LR]\n\n  # several \"node\" statements\n  node [shape = circle,\n        fixedsize = true,\n        width = 0.5,\n        style = filled,\n        color = grey]\n  node [fillcolor = PowderBlue]\n  A; B\n\n  # several \"edge\" statements\n  A->B [dir = \"both\", arrowhead = inv arrowtail = inv]\n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>

]

&lt;br&gt;

- Используются в качестве исходных данных для многих видов многомерных анализов, в т.ч. для неметрического многомерного шкалирования и некоторых видов кластерного анализа
- Из сходств можно получить расстояния и наоборот
- Свои коэффициенты для количественных и качественных признаков

---

## Свойства коэффициентов сходства-различия

.pull-left-33[
**Метрики и полуметрики**

Адекватность: `\(d_{A, A} = 0\)`

&lt;!-- ```{r, echo=FALSE, fig.width=4, fig.height=.5} --&gt;
&lt;!-- DiagrammeR("images/adequa.gv", type = "grViz") --&gt;
&lt;!-- # system('dot -Tpdf images/adequa.gv -o images/adequa.pdf') --&gt;
&lt;!-- ``` --&gt;

![](images/adequa.pdf)


Симметричность: `\(d_{A, B} = d_{B, A}\)`

<div class="grViz html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-6906f30835a95f91f4ee" style="width:288px;height:36px;"></div>
<script type="application/json" data-for="htmlwidget-6906f30835a95f91f4ee">{"x":{"diagram":"digraph symmetry {\n\n  # a \"graph\" statement\n  graph [overlap = false, fontsize = 10, rankdir = LR, labelloc = t, labeljust = c/*, label = \"Симметричность\"*/]\n\n  # several \"node\" statements\n  node [shape = circle,\n        fixedsize = true,\n        width = 0.5,\n        style = filled,\n        color = grey]\n  node [fillcolor = PowderBlue]\n  A; B\n\n  # several \"edge\" statements\n  A->B /*[label=<<font point-size=\"10\">d<sub><font point-size=\"5\">A, B<\/font><\/sub> = d<sub><font point-size=\"5\">B, A<\/font><\/sub><\/font>>]*/\n  B->A\n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>

![](images/symmetry.pdf)
]

.pull-right-66[

.pull-left[
**Только метрики**

Триангулярность: `\(d_{A, B} \le d_{A, C} + d_{C, B}\)`

<div class="grViz html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-d011e31636605cdcfe75" style="width:288px;height:72px;"></div>
<script type="application/json" data-for="htmlwidget-d011e31636605cdcfe75">{"x":{"diagram":"digraph symmetry {\n\n  # a \"graph\" statement\n  graph [overlap = false, fontsize = 10, rankdir = LR]\n\n  # several \"node\" statements\n  node [shape = circle,\n        fixedsize = true,\n        width = 0.5,\n        style = filled,\n        color = grey]\n  node [fillcolor = PowderBlue]\n  A; B; C\n\n  # several \"edge\" statements\n  A->B A->C C->B\n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>

![](images/triang.pdf)
]

.pull-right[
**Неметрики**

Все остальное
]
]

---

## Свойства коэффициентов сходства-различия

.pull-left[

**Нестандартные**

`$$-\infty \le d \le \infty$$`
]

.pull-right[

**Стандартные**

`$$d_{min} \le d \le d_{max}$$`

- частный случай стандартных коэффициентов - коррелятивные коэффициенты сходства

`$$-1 \le S \le 1$$`
]

---

## Примеры коэффициентов сходства-различия

.pull-left[
**Метрики (расстояния, distances):**

- без стандартизации:
    - Евклидово расстояние
    - Манхеттен (расстояние городских кварталов)

- со стандартизацией:
    - Канберра
    - хи-квадрат
    - Евклидово расстояние, рассчитанное по стандартизованным данным

**Полуметрики:**

- расстояние Махаланобиса
]

.pull-right[
**Неметрики:**

- со стандартизацией:
    - коррелятивные:
        - корреляция Пирсона
    - некоррелятивные:
        - коэффициент Брея-Куртиса
]

---

## Если количественные признаки измерены в одинаковых шкалах

**Метрики без стандартизации**

.pull-left[
- Евклидово расстояние

![](images/dist-euclid.png)
]

.pull-right[
Неевклидовы метрики

- Квадрат Евклидова расстояния

![](images/dist-euclid-sq.png)

- Манхэттеновское расстояние

![](images/dist-manhat.png)

]

---

## Если количественные признаки измерены в разных шкалах

**Можно стандартизовать исходные данные**

  - Евклидово (или другое) расстояние, рассчитанное по стандартизованным данным

**Можно использовать коэффициенты со стандартизацией**

- Канберра (метрика) `\(d = {\sum \frac {|x _{ik} - x _{jk}|} {|x _{ik}|+|x _{jk}|}}\)`
- хи-квадрат (метрика) `\(\chi^2 = \sqrt {\sum{ {\frac {1} {c _k}} (x _{ik} - x _{jk})^2 }}\)`
- Коэффициент Махаланобиса (неметрика) `\(d = \frac {\sum (x _{ik} - x _{jk})} {\sigma^2}\)`

- Корреляция Браве-Пирсона (коррелятивный) `\(S = \frac {\sum {(x _{ik} - \bar x _{i})(x _{ik} - \bar x _{j})}} {n \sigma^2 _{i} \sigma^2 _{j}}\)`

- Коэффициент Брея-Куртиса (не метрика) `\(BC _{ij} = \frac { 2C _{ij}} {S _i + S _j}\)`,
где `\(C _{ij}\)` - сумма минимальных значений из тех, которые не равны нулю для обоих объектов, `\(S _i\)` и `\(S _j\)` - общее число ненулевых значений признаков для обоих объектов.

---

## Если признаки --- подсчеты численности

**Можно стандартизовать исходные данные**

Простая стандартизация не подходит (у счетных признаков не может быть среднее 0)

Можно использовать трансформации:

- корень, корень 4-й степени
- логарифмирование со сдвигом (log10(x + 1))

**Можно использовать коэффициенты со стандартизацией**

- Канберра (метрика) `\(d = {\sum \frac {|x _{ik} - x _{jk}|} {|x _{ik}|+|x _{jk}|}}\)`

- хи-квадрат (метрика) `\(\chi^2 = \sqrt {\sum{ {\frac {1} {c _k}} (x _{ik} - x _{jk})^2 }}\)`

---

## Если признаки --- доли или проценты

- хи-квадрат (метрика) `\(\chi^2 = \sqrt {\sum{ {\frac {1} {c _k}} (x _{ik} - x _{jk})^2 }}\)`
- коэффициент Брея-Куртиса (не метрика) `\(BC _{ij} = \frac { 2C _{ij}} {S _i + S _j}\)`

- Евклидово расстояние `\(d = \sqrt {\sum{(x _{ik} + x _{jk})^2}}\)`

---

## Если используются бинарные данные (присутствие-отсутствие признака)

В основе лежит четырехпольная таблица

`$$\begin{vmatrix} \, &amp; + &amp; - \\ + &amp; a &amp; b \\ - &amp; c &amp; d \end{vmatrix}$$`

- a - сходство объектов по наличию признака
- b - различие
- c - различие
- d - сходство по отсутствию признака

---

## Примеры коэффициентов для качественных данных

`$$\begin{vmatrix} \, &amp; + &amp; - \\ + &amp; a &amp; b \\ - &amp; c &amp; d \end{vmatrix}$$`

.small[

|Коэффициент | Формула | Источник |
|------|--------|--------|
| Simple matching | `\(\frac{a + d} {a + b + c + d}\)` | Sokal and Michener, 1958 |
| Rogers and Tanimoto | `\(\frac{a + d} {a + 2b + 2c + d}\)` | Rogers and Tanimoto, 1960 |
| Anderberg | `\(\frac{a + d} {a + 2(b + c)}\)` | Anderberg, 1973 |
| Russel and Rao | `\(\frac{a} {a + b + c + d}\)` | Russel and Rao, 1940 |
| Jaccard | `\(\frac{a} {a + b + c}\)` | Jaccard, 1901 |
| Sorensen-__Dice__ | `\(\frac{2a} {2a + b + c}\)` | Dice, 1945, Sorensen, 1948 |
]

И т.д.

---

## Если данные смешанные (качественные и количественные)

### Коэффициенты для смешанных данных

- расстояние Говера

`$$D = \frac{1}{p} \frac{\sum W_i\dfrac{\mid x_{i,j} - x_{i,k} \mid}{\max x_{i,j} - \min x_{i,k}}}{\sum W_i}$$`

`\(W_i=0\)` Если отсутствует информация o `\(x_{i,j}\)` и/или `\(x_{i,k}\)` отсутствует     

`\(W_i=1\)` Если присутствует информация как о `\(x_{i,j}\)` так и о `\(x_{i,k}\)`

---

class: center, middle, inverse

## Неметрическое многомерное шкалирование

---

## Неметрическое многомерное шкалирование визуализирует отношения между объектами на основе расстояний между ними

.pull-left[

![](09_dist_files/figure-html/gg-eu-1.png)&lt;!-- --&gt;
]

.pull-right[

Если бы мы знали расстояния по автодорогам между городами Европы


```
          Athens Barcelona Brussels Calais
Barcelona   3313                          
Brussels    2963      1318                
Calais      3175      1326      204       
Cherbourg   3339      1294      583    460
```

мы бы смогли восстановить по ним карту

&lt;img src="09_dist_files/figure-html/eu-1.png" width="2in" height="1.9in" /&gt;
]

---

## Неметрическое многомерное шкалирование

Неметрическое многомерное шкалирование (nonmetric multidimensional scaling, nMDS) --- метод визуализации отношений между объектами в пространстве с небольшим числом измерений.

Исходные данные --- матрица расстояний между объектами в многомерном пространстве.



.pull-left[

- nMDS подбирает расстояния между объектами на графике так, чтобы сохранились соотношение исходных расстояний между ними. Т.е. если исходно A и B были ближе, чем B и С, то и в результате они должны быть ближе, чем B и С.

- Ординацию nMDS можно поворачивать,  отражать, сдвигать - результат от этого не изменится.
]


.pull-right[

![](09_dist_files/figure-html/eu-1.png)&lt;!-- --&gt;
]

---

## Пример: Морфометрия поссумов

.pull-left[
![](images/possum.jpg)

.tiny[
Possum by Hasitha Tudugalle on [Flickr](https://www.flickr.com/photos/hasitha\_tudugalle/6037880962)
]
]


.pull-right[

В датафрейме содержатся данные об измерениях поссумов в разных частях тела. Кроме того, есть ещё и факторные переменные: 

- site --- места, в которых поссумы были пойманы (7 локаций)

- Pop --- популяция, к которой поссумы относятся (`Victoria` или `other`)

- sex --- пол поссума (`f` или `m`)

.tiny[
Данные Lindenmayer et al. (1995)
]
]

---

## Знакомимся с данными


```r
library(DAAG)
data(possum)
colnames(possum)
```

```
 [1] "case"     "site"     "Pop"      "sex"      "age"      "hdlngth"  "skullw"  
 [8] "totlngth" "taill"    "footlgth" "earconch" "eye"      "chest"    "belly"   
```

```r
colSums(is.na(possum))
```

```
    case     site      Pop      sex      age  hdlngth   skullw totlngth    taill 
       0        0        0        0        2        0        0        0        0 
footlgth earconch      eye    chest    belly 
       1        0        0        0        0 
```

```r
# оставим только строки с полными наблюдениями
pos &lt;- possum[complete.cases(possum), ]
# поссумы из разных сайтов из 2 популяций
table(pos$Pop, pos$site)
```

```
       
         1  2  3  4  5  6  7
  Vic   33 10  0  0  0  0  0
  other  0  0  7  7 13 13 18
```

---

## Неметрическое многомерное шкалирование

Построим ординацию поссумов на основе их сходства по морфометрии и возрасту.

Функция metaMDS много раз итеративно подбирает координаты поссумов в новом пространстве (двумерном по умолчанию) и сохраняет лучшую конфигурацию.

`autotransform` --- если `TRUE`, то данные предварительно подвергаются двойной ("висконсинской") стандартизации (см. `?metaMDS`). __Если у вас не данные о сообществах, то это нужно отключить__


```r
library(vegan)
ord_euclid &lt;- metaMDS(pos[, 6:14], distance = "euclid", autotransform = FALSE)
```

```
Run 0 stress 0.1035 
Run 1 stress 0.12 
Run 2 stress 0.4122 
Run 3 stress 0.1035 
... New best solution
... Procrustes: rmse 0.00001117  max resid 0.00007916 
... Similar to previous best
Run 4 stress 0.1035 
... New best solution
... Procrustes: rmse 0.000002265  max resid 0.00001586 
... Similar to previous best
Run 5 stress 0.12 
Run 6 stress 0.1035 
... Procrustes: rmse 0.000003184  max resid 0.00002206 
... Similar to previous best
Run 7 stress 0.1035 
... Procrustes: rmse 0.000005263  max resid 0.0000257 
... Similar to previous best
Run 8 stress 0.12 
Run 9 stress 0.1035 
... Procrustes: rmse 0.000007875  max resid 0.00005542 
... Similar to previous best
Run 10 stress 0.12 
Run 11 stress 0.1035 
... New best solution
... Procrustes: rmse 0.000006282  max resid 0.00005859 
... Similar to previous best
Run 12 stress 0.12 
Run 13 stress 0.12 
Run 14 stress 0.12 
Run 15 stress 0.1035 
... Procrustes: rmse 0.000003093  max resid 0.0000228 
... Similar to previous best
Run 16 stress 0.1035 
... Procrustes: rmse 0.000001957  max resid 0.00001153 
... Similar to previous best
Run 17 stress 0.1035 
... Procrustes: rmse 0.000005094  max resid 0.00003562 
... Similar to previous best
Run 18 stress 0.1035 
... Procrustes: rmse 0.000002979  max resid 0.00001824 
... Similar to previous best
Run 19 stress 0.12 
Run 20 stress 0.12 
*** Best solution repeated 5 times
```

---

## Качество подгонки модели

__stress__ - оценивает, насколько были искажены исходные расстояния между объектами при снижении размерности


```r
ord_euclid$stress
```

```
[1] 0.1035
```

- Эмпирическое правило: хорошо &lt; 0.25 (или, иногда, 0.20) &lt; плохо

---

## Ординация

.pull-left[
Координаты наблюдений:


```r
head(ord_euclid$points, 10)
```

```
       MDS1   MDS2
C3   -8.367 -4.596
C5   -5.349 -2.057
C10 -11.487 -1.414
C15  -8.361 -3.624
C23  -1.886 -4.743
C24  -5.778 -5.346
C26  -5.838 -1.542
C27  -7.102 -2.983
C28  -5.744 -2.972
C31  -3.875 -3.237
```
]


.pull-right[
График ординации:


```r
ordiplot(ord_euclid, type = "t")
```

![](09_dist_files/figure-html/fig-ugly-ord-1.png)&lt;!-- --&gt;
]

---

## Задание 1

При помощи `ggplot2` постройте график неметрического многомерного шкалирования.  
Для графика используйте координаты точек `ord_euclid$points` и исходные данные.  
Раскрасьте график по значениям переменной `Pop`.  
Сделайте так, чтобы особи разного пола были изображены на разных панелях

![](09_dist_files/figure-html/fig-ord-1.png)&lt;!-- --&gt;

---

## Дополните код


```r
library()
# Данные для графика
points_euclid &lt;- data.frame( , )
# График nMDS ординации
gg_euclid &lt;- ggplot(, aes(x = , y = )) +
  geom_point() + 
  facet_wrap(~ )
gg_euclid
```

---

## Решение: график ординации


```r
library(ggplot2)
# Данные для графика
points_euclid &lt;- data.frame(pos, ord_euclid$points)
# График nMDS ординации
gg_euclid &lt;- ggplot(points_euclid, aes(x = MDS1, y = MDS2)) +
  geom_point(aes(colour = Pop), alpha = 0.5) + 
  facet_wrap(~sex)
gg_euclid
```

![](09_dist_files/figure-html/fig-ord-1.png)&lt;!-- --&gt;

---

## Задание 2

Постройте nMDS ординацию при помощи евклидова расстояния, по стандартизованным данным

Дополните код


```r
# Ординация
ord_scaled &lt;- metaMDS( (pos), distance = , autotransform = )
# Качество ординации
```

---

## Решение:

.small[


```r
# Ординация
ord_scaled &lt;- metaMDS(scale(pos[, 6:14]), distance = "euclide", autotransform = FALSE)
```

```
Run 0 stress 0.1471 
Run 1 stress 0.1509 
Run 2 stress 0.1509 
Run 3 stress 0.1471 
... Procrustes: rmse 0.0006925  max resid 0.005465 
... Similar to previous best
Run 4 stress 0.1471 
... New best solution
... Procrustes: rmse 0.0008168  max resid 0.005897 
... Similar to previous best
Run 5 stress 0.151 
Run 6 stress 0.1471 
... Procrustes: rmse 0.0006916  max resid 0.005466 
... Similar to previous best
Run 7 stress 0.1471 
... Procrustes: rmse 0.001069  max resid 0.005865 
... Similar to previous best
Run 8 stress 0.1471 
... New best solution
... Procrustes: rmse 0.00001584  max resid 0.00006659 
... Similar to previous best
Run 9 stress 0.151 
Run 10 stress 0.1471 
... Procrustes: rmse 0.0008181  max resid 0.005911 
... Similar to previous best
Run 11 stress 0.1471 
... New best solution
... Procrustes: rmse 0.000004956  max resid 0.00001664 
... Similar to previous best
Run 12 stress 0.1509 
Run 13 stress 0.1509 
Run 14 stress 0.151 
Run 15 stress 0.1471 
... Procrustes: rmse 0.001072  max resid 0.005917 
... Similar to previous best
Run 16 stress 0.1509 
Run 17 stress 0.1471 
... Procrustes: rmse 0.000005657  max resid 0.00003511 
... Similar to previous best
Run 18 stress 0.151 
Run 19 stress 0.1471 
... Procrustes: rmse 0.001078  max resid 0.005971 
... Similar to previous best
Run 20 stress 0.1509 
*** Best solution repeated 4 times
```

```r
# Качество ординации
ord_scaled$stress
```

```
[1] 0.1471
```
] 

Для сравнения, стресс был

```r
ord_euclid$stress
```

```
[1] 0.1035
```

Похоже, что в этом случае лучшая ординация была получена при использовании евклидова расстояния без стандартизации --- у нее меньше значение стресса.

Но сейчас мы продолжим: сравним графики обеих ординаций.

---

## График ординации по матрице евклидовых расстояний, рассчитанных по стандартизованным данным


```r
# Данные для графика
points_scaled &lt;- data.frame(ord_scaled$points, pos)
# График nMDS-ординации
gg_scaled &lt;- gg_euclid %+% points_scaled
gg_scaled
```

![](09_dist_files/figure-html/fig-ord-raw-1.png)&lt;!-- --&gt;

---

## Видно, что графики ординации, полученные разными методами, различаются

![](09_dist_files/figure-html/gg-both-1.png)&lt;!-- --&gt;

---

## Код для графиков


```r
library(gridExtra)
grid.arrange(gg_euclid + aes(size = age),
             gg_scaled + aes(size = age),
             ncol = 1)
```

---

class: middle, center, inverse

## Кластерный анализ

---

## Пример: Морфометрия самок поссумов


```r
# library(DAAG)
data(fossum)
```

Данные для кластерного анализа нужно подготовить:

- создать осмысленные имена строк
- выбрать только переменные, нужные для построения матрицы сходств-различий
- выбрать только строки без пропусков

---

## Создаем "говорящие" названия строк

Сейчас в названиях строк записано из какой точки каждый поссум

```r
rownames(fossum) # было
```

```
 [1] "C5"    "C10"   "C15"   "C23"   "C24"   "C27"   "C28"   "C31"   "C32"   "C34"  
[11] "C45"   "C48"   "C50"   "C54"   "C58"   "C63"   "A1"    "A2"    "A4"    "BB17" 
[21] "BB31"  "BB33"  "BB36"  "BB40"  "WW4"   "WW5"   "WW7"   "BR4"   "BR7"   "CD2"  
[31] "CD3"   "CD4"   "CD5"   "CD6"   "CD10"  "BSF1"  "BSF9"  "BSF10" "BSF13" "BTP3" 
[41] "BTP15" "BTP19" "BTP21"
```

Чтобы имена строк были более информативны, добавим к ним название популяции


```r
rownames(fossum) &lt;- paste(fossum$Pop, 
                          rownames(fossum), 
                          sep = "_")
rownames(fossum) # стало
```

```
 [1] "Vic_C5"      "Vic_C10"     "Vic_C15"     "Vic_C23"     "Vic_C24"    
 [6] "Vic_C27"     "Vic_C28"     "Vic_C31"     "Vic_C32"     "Vic_C34"    
[11] "Vic_C45"     "Vic_C48"     "Vic_C50"     "Vic_C54"     "Vic_C58"    
[16] "Vic_C63"     "Vic_A1"      "Vic_A2"      "Vic_A4"      "Vic_BB17"   
[21] "Vic_BB31"    "Vic_BB33"    "Vic_BB36"    "Vic_BB40"    "other_WW4"  
[26] "other_WW5"   "other_WW7"   "other_BR4"   "other_BR7"   "other_CD2"  
[31] "other_CD3"   "other_CD4"   "other_CD5"   "other_CD6"   "other_CD10" 
[36] "other_BSF1"  "other_BSF9"  "other_BSF10" "other_BSF13" "other_BTP3" 
[41] "other_BTP15" "other_BTP19" "other_BTP21"
```

---

## Отбираем только то, что понадобится для кластеризации

Отбираем  
только строки без пропущенных значений, 
и только столбцы с морфометрическими данными


```r
fos &lt;- fossum[complete.cases(fossum), 6:14]
```

---

## Методы кластеризации

.pull-left[
### Иерархические методы

- методы построения деревьев (о них следующие слайды)
]

.pull-right[
### Неиерархические методы

- кластеризация K-means 
- кластеризация C-means 
- основанная на плотности пространственная кластеризация для приложений с шумами (DBSCAN)
- упорядочение точек для обнаружения кластерной структуры (OPTICS)

]

---

## Какие бывают методы построения деревьев?

.pull-left[
### Методы класстеризации на основании расстояний (о них сегодня пойдет речь)
  - Метод ближайшего соседа (single linkage)
  - Метод отдаленного соседа (complete linkage)
  - Метод среднегруппового расстояния (average linkage, UPGMA)
  - Метод Варда (Ward's method)
  - Метод присоединения соседей (Neighbour Joining)

Эти методы есть в базовом пакете `stats`, и в пакете `ape`. Разные полезные функции есть в `ade4` и `adegenet`
]

.pull-right[
### Методы кластеризации на основании признаков
  - Метод максимальной бережливости 
  - Метод максимального правдоподобия
  
Эти методы реализованы в пакете `phangorn` 

Со списком пакетов для филогенетического анализа в R можно познакомиться здесь:  
https://cran.r-project.org/web/views/Phylogenetics.html
]

---

class: middle, center, inverse

## Методы класстеризации на основании расстояний

---

## От чего зависит результат кластеризации

Результат кластеризации зависит от

- коэффициента сходства-различия
- от алгоритма кластеризации

---

## Кластерный анализ начинается с расчета матрицы расстояний между объектами

Далее мы будем использовать матрицу евклидовых расстояний между поссумами.


```r
d &lt;- dist(x = fos, method = "euclidean")
```

Давайте построим деревья при помощи нескольких алгоритмов кластеризации и сравним их.

---

## Методы кластеризации

![](09_dist_files/figure-html/gg-all-1.png)&lt;!-- --&gt;

---

## Метод ближайшего соседа

.pull-left[
- = nearest neighbour = single linkage
- к кластеру присоединяется ближайший к нему кластер/объект
- кластеры объединяются в один на расстоянии, которое равно расстоянию между ближайшими объектами этих кластеров
]

.pull-right[
![](09_dist_files/figure-html/gg-single-1.png)&lt;!-- --&gt;
]

**Особенности:**

- Может быть сложно интерпретировать, если нужны группы
  - объекты на дендрограмме часто не образуют четко разделенных групп
  - часто получаются цепочки кластеров (объекты присоединяются как бы по-одному)
- Хорош для выявления градиентов

---

## Как работает метод ближайшего соседа



![](09_dist_files/figure-html/fig-single-guess-1.png)&lt;!-- --&gt;

---

## Как работает метод ближайшего соседа 

![](09_dist_files/figure-html/single-ani-.gif)&lt;!-- --&gt;

---

## Метод ближайшего соседа в R


```r
hc_single &lt;- hclust(d, method = "single")
library(ape)
ph_single &lt;- as.phylo(hc_single)
# cex - относительный размер шрифта
plot(ph_single, type = "phylogram", direction = "downwards", cex = 0.7)
axisPhylo(side = 2)
```

![](09_dist_files/figure-html/fig-single-1.png)&lt;!-- --&gt;

---

## Метод отдаленного соседа

.pull-left[
- = furthest neighbour = complete linkage
- к кластеру присоединяется отдаленный кластер/объект
- кластеры объединяются в один на расстоянии, которое равно расстоянию между самыми отдаленными объектами этих кластеров (следствие - чем более крупная группа, тем сложнее к ней присоединиться)
]

.pull-right[
![](09_dist_files/figure-html/gg-compl-1.png)&lt;!-- --&gt;
]

**Особенности:**

- На дендрограмме образуется много отдельных некрупных групп
- Хорош для поиска дискретных групп в данных

---

## Как работает метод отдаленного соседа

![](09_dist_files/figure-html/fig-complete-guess-1.png)&lt;!-- --&gt;

---

## Как работает метод отдаленного соседа

![](09_dist_files/figure-html/complete-ani-.gif)&lt;!-- --&gt;

---

## Метод отдаленного соседа в R


```r
ph_compl &lt;- as.phylo(hclust(d, method = "complete"))
plot(ph_compl, type = "phylogram", direction = "downwards", cex = 0.8)
axisPhylo(side = 2)
```

![](09_dist_files/figure-html/fig-compl-1.png)&lt;!-- --&gt;

---

## Метод невзвешенного попарного среднего

.pull-left[
- = UPGMA = Unweighted Pair Group Method with Arithmetic mean
- кластеры объединяются в один на расстоянии, которое равно среднему значению всех возможных расстояний между объектами из разных кластеров.
]

.pull-right[
![](09_dist_files/figure-html/gg-avg-1.png)&lt;!-- --&gt;
]

**Особенности:**
UPGMA и WUPGMС иногда могут приводить к инверсиям на дендрограммах

![width=0.5\linewidth](images/clust-revert.png)

.tiny[
из Borcard et al., 2011
]

---

## Как работает метод невзвешенного попарного среднего

![](09_dist_files/figure-html/average-ani-.gif)&lt;!-- --&gt;

---

## Метод невзвешенного попарного среднего в R


```r
ph_avg &lt;- as.phylo(hclust(d, method = "average"))
plot(ph_avg, type = "phylogram", direction = "downwards", cex = 0.8)
axisPhylo(side = 2)
```

![](09_dist_files/figure-html/fig-avg-1.png)&lt;!-- --&gt;

---

## Метод Варда

.pull-left[
- = Ward's Minimum Variance Clustering
- объекты объединяются в кластеры так, чтобы внутригрупповая дисперсия расстояний была минимальной
]


.pull-right[
![](09_dist_files/figure-html/gg-ward-1.png)&lt;!-- --&gt;
]

**Особенности:**

- метод годится и для неевклидовых расстояний несмотря на то, что внутригрупповая дисперсия расстояний рассчитывается так, как будто это евклидовы расстояния

---

## Как работает метод Варда

![](09_dist_files/figure-html/ward-ani-.gif)&lt;!-- --&gt;

---

## Метод Варда в R


```r
ph_w2 &lt;- as.phylo(hclust(d, method = "ward.D2"))
plot(ph_w2, type = "phylogram", direction = "downwards", cex = 0.8)
axisPhylo(side = 2)
```

![](09_dist_files/figure-html/fig-ward-1.png)&lt;!-- --&gt;

---

class: middle, center, inverse

## Cравнение и интерпретация результатов кластеризации

---

## Кофенетическая корреляция

Кофенетическое расстояние --- расстояние между объектами на дендрограмме.

Кофенетическую корреляцию можно рассчитать как пирсоновскую корреляцию (обычную) между матрицами исходных и кофенетических расстояний между всеми парами объектов. 

Метод, который дает наибольшую кофенетическую корреляцию, дает кластеры, лучше всего отражающие исходные данные.

---

## Кофенетическая корреляция в R


```r
# Кофенетические расстояния
c_single &lt;- as.dist(cophenetic(ph_single))
c_compl &lt;- as.dist(cophenetic(ph_compl))
c_avg &lt;- as.dist(cophenetic(ph_avg))
c_w2 &lt;- as.dist(cophenetic(ph_w2))
```


```r
# Кофенетические корреляции
cor(d, c_single)
```

```
[1] 0.7483
```

```r
cor(d, c_compl)
```

```
[1] 0.5989
```

```r
cor(d, c_avg) 
```

```
[1] 0.8084
```

```r
cor(d, c_w2)
```

```
[1] 0.6927
```

---

## На каком уровне нужно делить дендрограмму на кластеры?

- Можно субъективно, на любом выбранном уровне. Главное, чтобы кластеры были осмысленными и интерпретируемыми.
- Можно выбрать, глядя на распределение расстояний ветвления
- Можно оценить вероятность разделения на кластеры при помощи бутстрепа

---

## Бутстреп-поддержка ветвей

Функция `system.time` - покажет, сколько времени заняли рассчеты

Аргументы `pvclust`:

- `nboot` --- число итераций должно быть больше 10000. В примере мы используем мало для скорости
- `parallel = TRUE` --- проводить параллельные вычисления на нескольких ядрах процессора. Ускоряет расчеты
- `iseed` --- зерно генератора случайных чисел для вычислений. Обязательно задавайте этот аргумент, если хотите, чтобы вычисления воспроизводились при повторных запусках


```r
library(pvclust)
```


```r
system.time({
cl_boot &lt;- pvclust(scale(t(fos)), 
                   method.hclust = "average", 
                   method.dist = "euclidean",
                   nboot = 5000,
                   parallel = TRUE,
                   iseed = 42)
})
```

```
Creating a temporary cluster...done:
socket cluster with 11 nodes on host 'localhost'
Multiscale bootstrap... Done.
```

```
   user  system elapsed 
  0.168   0.235  26.077 
```

---

## Бутстреп-поддержка ветвей 


```r
plot(cl_boot, cex.pv = 0.8, cex = 0.8)
```

![](09_dist_files/figure-html/fig-pvclust-1.png)&lt;!-- --&gt;

---

class: middle, center, inverse

## Построение деревьев по генетическим данным

---

## Teaser

В этом курсе нет возможности рассказать даже о малой доле возможностей R для работы с генетическими данными, поэтому давайте сделаем небольшую демонстрацию.

---

## Пример: Митохондриальная ДНК приматов.

В файле primates.dna содержатся последовательности участка митохондриальной ДНК. для 12 видов приматов. Последовательности для мыши и коровы --- в качестве аутгруппы. (232bp в контрольном участке плюс третий кодон в близлежащих белок-кодирующих митохондриальных генах --- 1-2 кодоны исключены в попытке получить сходную скорость эволюции во всех сайтах)

Датасет собан Dr. Masami Hasegawa (Institute of Statistical Mathematics, Tokyo), по данным сиквенирования Kenji Hayasaka, Takashi Gojobori, Satoshi Horai (Molecular Biology and Evolution 5: 626-644, 1988).

Исходный файл в формате PHYLIP можно загрузить по ссылке: http://evolution.genetics.washington.edu/book/primates.dna

---

## Дерево по генетическим данным


```r
webpage &lt;-"http://evolution.genetics.washington.edu/book/primates.dna"
primates.dna &lt;- read.dna(webpage)
d_pri &lt;- dist.dna(primates.dna, model = "K80")
hc_pri &lt;- hclust(d_pri, method = "average")
ph_pri &lt;- as.phylo(hc_pri)
plot(ph_pri, cex = 0.8)
axisPhylo()
```

&lt;img src="09_dist_files/figure-html/fig-gen-tree-1.png" width="4.5in" height="2in" /&gt;

---

class: middle, center, inverse

## Неиерархические методы кластеризации

---

## K-means кластеризация

.pull-left[
![](09_dist_files/figure-html/unnamed-chunk-23-1.png)&lt;!-- --&gt;
]

.pull-right[
В отличие от иерархических методов кластеризации K-means будет искать то количество кластеров, которое вы ему зададите (в количестве k штук). Каждое наблюдение принадлежит кластеру с ближайшим значением среднего числа (центроида); помимо этого K-means кластеризация минимизирует разброс значений внутри каждого из кластера.

Используется в машинном обучении, в том числе, например, для цветовой редуцкии изображений. 
]

---

## Алгоритм K-means кластеризации

.pull-left[
### График наблюдений 
![](09_dist_files/figure-html/unnamed-chunk-24-1.png)&lt;!-- --&gt;

Здесь как будто бы выделяются 3 кластера, поэтому возьмём k = 3. Что же будет делать алгоритм?
]

--

.pull-right[
### 1. Выбираются случайным образом 3 точки на графике --- кластерные центроиды

Например, так:

![](09_dist_files/figure-html/unnamed-chunk-25-1.png)&lt;!-- --&gt;
]

---

## Алгоритм K-means кластеризации 

.pull-left[
### 2. Измеряется Евклидово расстояние между каждой точкой и центроидом 

При этом каждая точка приписывается к ближайшему кластеру. 

![](09_dist_files/figure-html/unnamed-chunk-26-1.png)&lt;!-- --&gt;
]

.pull-right[
### 3. Расситываются центроиды для каждого кластера

![](09_dist_files/figure-html/unnamed-chunk-27-1.png)&lt;!-- --&gt;
]

---

## 4. Расчёт расстояний от каждой точки до нового центроида 

.pull-left[
Также оценивается разброс внутри каждого кластера.

![](09_dist_files/figure-html/unnamed-chunk-28-1.png)&lt;!-- --&gt;
]

.pull-right[
Разброс считается как сумма квадратов расстояний между отдельными наблюдениями и центроидом.

$$ \sum_{i=1}^{n}(x_i - \overline{x})$$
]

---

## 5. Повторяем всё многократно до тех пор, пока разброс не станет минимальным

Кластеры с минимальным разбросом --- финальные. 

![](09_dist_files/figure-html/unnamed-chunk-29-1.png)&lt;!-- --&gt;

---

## Подбор количества кластеров

А что, если на глаз не видно точное количество кластеров?.. 

![](09_dist_files/figure-html/unnamed-chunk-30-1.png)&lt;!-- --&gt;

Может быть тут два кластера?.. Чтобы определить оптимальное количество нам также понадобится сумма квадратов была минимальной. 

Чтобы разобраться, перейдём к коду в R. 

---

# K-means в R

.pull-left[
В первую очередь стандартизуем данные.


```r
f_sc &lt;- scale(fos)
```

Визуализацию изменения суммы квадратов можно посмотреть с помощью функции `fviz_nbclust` из пакета `factoextra`.
]

.pull-right[

```r
library(factoextra)
fviz_nbclust(f_sc, kmeans, method = "wss")
```

![](09_dist_files/figure-html/unnamed-chunk-32-1.png)&lt;!-- --&gt;
]

Определяем точку (в английской литературе её называют elbow), после которой менее резко начинает изменяться within sum of squares. В нашем случае это 4. 

---

## K-means кластеризация и визуализация


```r
f_kmeans &lt;- kmeans(f_sc, centers = 4, nstart = 20) # проводим кластеризацию

my_col &lt;- c("#2E9FDF", "#FF5AD9", "#B5FF0A", "#F37352") # создаём вектор цветов для раскраски

# визуализируем
fviz_cluster(f_kmeans, data = f_sc,
             palette = my_col,
             ggtheme = theme_bw())
```

![](09_dist_files/figure-html/unnamed-chunk-33-1.png)&lt;!-- --&gt;

---

## Density-based spatial clustering of applications with noise (DBSCAN)

.pull-left[
Основанная на плотности пространственная кластеризация для приложений с шумами --- метод, более подходящий для "вложенных" кластеров. Основан на распределении плотности точек. 

![](09_dist_files/figure-html/unnamed-chunk-34-1.png)&lt;!-- --&gt;
]

.pull-right[
Работает с данными, с которыми K-means справиться не может. Как, например, тут. 

```r
set.seed(123)
circle_kmeans &lt;- kmeans(multi, centers = 2, nstart = 20)
my_col_circle &lt;- c("#2E9FDF", "#E7B800")
fviz_cluster(circle_kmeans, data = multi,
             palette = my_col_circle)
```

![](09_dist_files/figure-html/unnamed-chunk-35-1.png)&lt;!-- --&gt;
]

---

## Принцип работы DBSCAN 

Кластеры выбираются на основе плотности расположения точек. В результате в единый кластер объединяются близко расположенные друг к другу точки. 
Исследователем задаются два важных параметра для объединения точек в один кластер:
- радиус расстояния, на котором должны рассматриваться близлежащие точки (`eps`)
- минимальное количество точек, которые расположены в круге этого радиуса (`minPts`)

Сore points --- точки, от которых можем присоединять в кластер новые точки и рядом с которыми расположено `minPts` количество точек. Есть ещё пограничные точки --- те, на которых кластер заканчивается. Остальные точки считаются шумом и выбросами.  

---

## DBSCAN в R

Провести такую кластеризацию можно с помощью функции `dbscan` из пакета `dbscan`. 

![](09_dist_files/figure-html/unnamed-chunk-36-1.png)&lt;!-- --&gt;

---

## Epsilon --- выбираем расстояние для радиуса

Можно посмотреть на график k-расстояний (k-distance plot): поскольку мы предполагаем, что у точек одного кластера расстояние будет одинаковым, а у точек из шума расстояние будет больше. Вычислить среднее значение расстояний каждой точки до ее k ближайших соседей. Далее эти k-расстояния отображаются в порядке возрастания. Если на графике есть "колено" --- значительный перегиб, будет легко найти нужное значение радиуса. 
.pull-left[

```r
kNNdistplot(multi, k = 5)
abline(h = 0.23, lty = 2)
```

![](09_dist_files/figure-html/unnamed-chunk-37-1.png)&lt;!-- --&gt;
]
.pull-right[

```r
circle_dbscan &lt;- dbscan(multi, 0.23, 5)
fviz_cluster(circle_dbscan, data = multi,
             palette = my_col_circle)
```

![](09_dist_files/figure-html/unnamed-chunk-38-1.png)&lt;!-- --&gt;
]

---

## Задание

Кластеризуйте данные по поссумам, используя DBSCAN-алгоритм.

---

## Примерное решение

.pull-left[

```r
kNNdistplot(f_sc, k = 5)
abline(h = 2.3, lty = 2) 
```

![](09_dist_files/figure-html/unnamed-chunk-39-1.png)&lt;!-- --&gt;
]

.pull-right[

```r
pos_db &lt;- dbscan(f_sc, 2.3, 5)
fviz_cluster(pos_db, data = f_sc,
             palette = my_col)
```

![](09_dist_files/figure-html/unnamed-chunk-40-1.png)&lt;!-- --&gt;
]

Не очень красиво получилось. Нет близко расположенных точек, и многие наблюдения читаются как выбросы.

---

## Take home messages

- Неметрическое многомерное шкалирование (nMDS):
    - nMDS --- способ снижения размерности, сохраняющий ранги расстояний между объектами
    - Направления на графике многомерного шкалирования можно интерпретировать произвольным образом в зависимости от изменения других переменных (не обязательно вдоль осей)
    - Результат многомерного шкалирования зависит от выбора коэффициента различия
    - Стресс --- мера оценки качества ординации nMDS

- Кластерный анализ:
    - Бывает иерархическим и неиерархическим. Какой использовать --- зависит от ваших целей и задач
    - Результат кластеризации зависит не только от выбора коэффициента, но и от выбора алгоритма кластеризации
    - Кофенетическая корреляция --- мера оценки соответствия расстояний на дендрограмме и коэффициентов сходства/различия в исходной матрице

---

## Дополнительные ресурсы

- Borcard, D., Gillet, F., Legendre, P., 2011. Numerical ecology with R. Springer.
- Legendre, P., Legendre, L., 2012. Numerical ecology. Elsevier.
- Oksanen, J., 2011. Multivariate analysis of ecological communities in R: vegan tutorial. R package version 2–0.
- Quinn, G.G.P., Keough, M.J., 2002. Experimental design and data analysis for biologists. Cambridge University Press.

- Как работает UPGMA: http://www.southampton.ac.uk/~re1u06/teaching/upgma/

- pvclust: An R package for hierarchical clustering with p-values [WWW Document], n.d. URL http://www.sigmath.es.osaka-u.ac.jp/shimo-lab/prog/pvclust/ (accessed 11.7.14).

Для анализа филогенетических данных:

- Paradis, E., 2011. Analysis of Phylogenetics and Evolution with R. Springer.
- Список пакетов для филогенетического анализа в R:  
https://cran.r-project.org/web/views/Phylogenetics.html
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="assets/macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "vs",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<!-- https://github.com/fnaufel/xaringan-smartify-->
<script type="text/javascript">
  smartify();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>

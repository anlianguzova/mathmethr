<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Знакомство с R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Анастасия Лянгузова" />
    <script src="site_libs/header-attrs-2.23/header-attrs.js"></script>
    <link href="site_libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="site_libs/remark-css-0.0.1/tamu-fonts.css" rel="stylesheet" />
    <link href="site_libs/remark-css-0.0.1/ninjutsu.css" rel="stylesheet" />
    <link href="site_libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="site_libs/tile-view-0.2.6/tile-view.js"></script>
    <script src="site_libs/fabric-4.3.1/fabric.min.js"></script>
    <link href="site_libs/xaringanExtra-scribble-0.0.1/scribble.css" rel="stylesheet" />
    <script src="site_libs/xaringanExtra-scribble-0.0.1/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30,"palette":[]}) })</script>
    <script src="site_libs/mark.js-8.11.1/mark.min.js"></script>
    <link href="site_libs/xaringanExtra-search-0.0.1/search.css" rel="stylesheet" />
    <script src="site_libs/xaringanExtra-search-0.0.1/search.js"></script>
    <script>window.addEventListener('load', function() { window.xeSearch = new RemarkSearch({"position":"bottom-left","caseSensitive":false,"showIcon":false,"autoSearch":true}) })</script>
    <script src="site_libs/xaringanExtra-progressBar-0.0.1/progress-bar.js"></script>
    <script src="site_libs/freezeframe-5.0.2/freezeframe.min.js"></script>
    <script src="site_libs/xaringanExtra-freezeframe-0.0.1/freezeframe-init.js"></script>
    <script id="xaringanExtra-freezeframe-options" type="application/json">{"selector":"img[src$=\"gif\"]","trigger":"click","overlay":false,"responsive":true,"warnings":true}</script>
    <link href="site_libs/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <!-- https://github.com/fnaufel/xaringan-smartify-->
    <script
    			  src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
    			  integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8="
    			  crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/fnaufel/xaringan-smartify/smartify.min.js"></script>
    <link rel="stylesheet" href="assets/xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="assets/xaringan.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: middle, left, inverse, title-slide

.title[
# Знакомство с R
]
.subtitle[
## Математические модели в зоологии
]
.author[
### Анастасия Лянгузова
]

---




---
class: middle, center, inverse

# Знакомство с R

---

## Загрузка, установка...

Собственно, сам [R](https://cran.r-project.org/)

[RStudio](posit.co) --- среда для разработки (IDE) на R

Онлайн IDE для R --- на тот случай, если у вас не установлен R:

-   &lt;https://posit.cloud&gt;

1.  Создайте папку, где будут храниться ВСЕ материалы курса. Эта папка будет **рабочей директорией**. В эту папку помещайте ВСЕ файлы с кодом (с расширением .R).
2.  Внутри папки `linmodr` создайте папку `data`, где будут храниться все файлы с данными для анализа.

В итоге у вас должно получиться примерно это:

    C:\linmodr\
    C:\linmodr\data\
    
---

## Установка рабочей директории

Есть несколько способов установки пути к рабочей директории:

1. Выберите в меню `Session -&gt; Set working Directory... -&gt; To Source File Location` (Если вы уже сохранили код).

2. На вкладке `Files` в одной из рабочих областей RStudio выберите многоточие `...` -&gt; в открывшемся системном диалоге выбора файлов найдите директорию, в которой лежит ваш код и нажмите OK

3. Можно вручную прописать путь к рабочей директории в кавычках в качестве аргумента функции `setwd()`


```r
setwd("~/linmodr")
```

Полезно создать в рабочей директории проект в формате `.Rproj` и работать, запуская проект. 

---

## Как получить помощь

1.  В RStudio можно поставить курсор на слово `setwd` и нажать `F1`
2.  Перед названием функции можно напечатать знак вопроса и выполнить эту строку `?setwd`
3.  Можно воспользоваться функцией `help()`


```r
help("setwd")
```

---

## R как калькулятор, математические операции


```r
2+2
```

```
[1] 4
```

```r
1024/2
```

```
[1] 512
```

```r
1:10
```

```
 [1]  1  2  3  4  5  6  7  8  9 10
```

```r
34*4
```

```
[1] 136
```

```r
2^4
```

```
[1] 16
```

```r
sqrt(27)
```

```
[1] 5.196
```

# Переменные

Оператор присваивания это символ стрелочки `&lt;-`. Он работает справа налево, это значит, что значение выражения в его правой части присваивается объекту в левой части.

Переменные - это такие контейнеры, в которые можно положить разные данные и даже функции.

Имена переменных могут содержать латинские буквы обоих регистров, символы точки . и подчеркивания \_ , а так же цифры. Имена переменных должны начинаться с латинских букв. Создавайте понятные и "говорящие" имена переменных.


```r
var_1 &lt;- 1024 / 2
1238 * 3 -&gt; var_2
var_2
```

```
[1] 3714
```

Как выбрать название переменной?

-   `a` - плохо, и даже `b`, `с`, или `х`. Но в некоторых случаях допустимо:)
-   `var1` - плохо, но уже лучше
-   `var_1` - плохо, но уже лучше
-   `shelllength` - говорящее, но плохо читается
-   `shell_length`, `wing_colour` или `leg_num` - хорошие говорящие и читабельные названия

# Векторы - одномерные структуры данных

Данные в R можно хранить в виде разных объектов.

В результате выполнения следующих команд числа. Одно выражение - одно значение.


```r
23
```

```
[1] 23
```

```r
sqrt(25)
```

```
[1] 5
```

На самом деле, эти величины - просто векторы единичной длины

*Векторы* - один объект, внутри которого несколько значений.

### Некоторые способы создания векторов:

-   Оператор: используется для создания целочисленных векторов, где значения следуют одно за другим без пропусков


```r
1:10 # от одного до 10
```

```
 [1]  1  2  3  4  5  6  7  8  9 10
```

```r
-5:3 # от -5 до 3
```

```
[1] -5 -4 -3 -2 -1  0  1  2  3
```

-   Функция `seq()` создает последовательности из чисел


```r
seq(from = 1, to = 5, by = 0.5)
```

```
[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0
```

-   Функция `c()` - от англ. concatenate. Следите, чтобы было английское си, а не русское эс:).


```r
?c # посмотрите хелп к функции
```

Функция `c` принимает несколько (произвольное количество) аргументов, разделенных запятыми. Она собирает из них вектор.


```r
c(2, 4, 6)
```

```
[1] 2 4 6
```

```r
c(-9.3, 0, 2.17, 21.3)
```

```
[1] -9.30  0.00  2.17 21.30
```

Векторы можно хранить в переменных для последующего использования


```r
vect_num &lt;- -11:12 # численный вектор от -11 до 12 сохранен в переменной vect_num
vect_num_1 &lt;- c(1.3, 1.7, 1.2, 0.9, 1.6, 1.4) # численный вектор, сохранен в переменной vect_num_1
```

### Адресация внутри векторов

При помощи оператора `[]`, можно обратится к некоторым элементам вектора. В квадратных скобках вам нужно указать один или несколько порядковых номеров элементов


```r
vect_num[1] # первый элемент в векторе vect_num
```

```
[1] -11
```

```r
vect_num[10] # 10-й элемент
```

```
[1] -2
```

```r
vect_num[22]
```

```
[1] 10
```

Если вам нужно несколько элементов, то их нужно передать квадратным скобкам в виде вектора. Например, нам нужны элементы с 3 по 5. Вот вектор, который содержит значения 3, 4 и 5.


```r
3:5
```

```
[1] 3 4 5
```

Если мы его напишем в квадратных скобках, то добудем элементы с такими порядковыми номерами


```r
vect_num[3:5]
```

```
[1] -9 -8 -7
```

Аналогично, если вам нужны элементы не подряд, то передайте вектор с номерами элементов, который вы создали при помощи функции c() c(2, 4, 6) \# это вектор содержащий 2, 4 и 6, поэтому


```r
vect_num[c(2, 4, 6)] # возвращает 2-й, 4-й и 6-й элементы
```

```
[1] -10  -8  -6
```

```r
vect_num[c(1, 10, 20)] # возвращает 1-й, 10-й и 20-й элементы
```

```
[1] -11  -2   8
```

Вектор - одномерный объект. У его элементов только один порядковый номер (индекс). Поэтому при обращении к элементам вектора нужно указывать только одно число или один вектор с адресами.

Правильно:


```r
vect_num[c(1, 2, 5)] # возвращает 1-й, 3-й и 5-й элементы
```

```
[1] -11 -10  -7
```

Но R выдаст ошибку, если при обращении к вектору, вы не создавали вектор, а просто перечислили номера элементов через запятую.


```r
vect_num[1, 3, 5] # ошибка
vect_num[15, 9, 1] # ошибка
```


```r
vect_num[c(15, 9, 1)] # правильно
```

```
[1]   3  -3 -11
```

При помощи функции c() можно объединять несколько векторов в один вектор


```r
c(1, 1, 5:9)
```

```
[1] 1 1 5 6 7 8 9
```

```r
c(vect_num, vect_num)
```

```
 [1] -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7   8
[21]   9  10  11  12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4
[41]   5   6   7   8   9  10  11  12
```

```r
c(100, vect_num)
```

```
 [1] 100 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7
[21]   8   9  10  11  12
```

Добываем 1, 3, 5 и с 22 по 24 элементы


```r
vect_num[c(1, 3, 5, 22:24)]
```

```
[1] -11  -9  -7  10  11  12
```

# Типы данных в R

## Числовые данные

Уже видели в прошлом разделе.

## Текстовые данные

Каждый текстовый элемент (говорят "строка" - string или character) должен быть окружен кавычками - двойными или одинарными.


```r
"это текст"
```

```
[1] "это текст"
```

```r
'это тоже текст'
```

```
[1] "это тоже текст"
```

Текстовые значения можно объединять в вектора.

Это текстовый вектор


```r
rainbow &lt;- c("red", "orange", "yellow", "green", "blue", "violet")
rainbow # весь вектор
```

```
[1] "red"    "orange" "yellow" "green"  "blue"   "violet"
```

Добываем первый и последний элементы

В данном случае я точно знаю, что их 6, мне нужны 1 и 6.


```r
rainbow[c(1, 6)]
```

```
[1] "red"    "violet"
```

Добываем элементы с 3 по 6

Если у вас вдруг слишком короткий вектор в этом задании, то можно склеить новый из двух


```r
double_rainbow &lt;- c(rainbow, rainbow)
double_rainbow
```

```
 [1] "red"    "orange" "yellow" "green"  "blue"   "violet" "red"    "orange" "yellow"
[10] "green"  "blue"   "violet"
```

```r
rainbow[3:6] # элементы с 3 по 6
```

```
[1] "yellow" "green"  "blue"   "violet"
```

## Логические данные


```r
TRUE # истина
```

```
[1] TRUE
```

```r
FALSE # ложь
```

```
[1] FALSE
```

Для ленивых - можно сокращать первыми заглавными буквами. **Но лучше так не делать**, чтобы читать программы было легче.


```r
c(T, T, T, T, F, F, T, T)
```

```
[1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE
```

Логический вектор


```r
c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)
```

```
[1]  TRUE  TRUE  TRUE FALSE FALSE  TRUE
```

Еще логический вектор


```r
short_logical_vector &lt;- c(FALSE, TRUE)
```

Создаем длинный логический вектор.

Чтобы создавать длинные вектора из повторяющихся элементов, можно использовать функцию rep()

    ?rep


```r
rep(x = 1, times = 3) # 1 повторяется 3 раза
```

```
[1] 1 1 1
```

```r
rep(x = "red", times = 5) # "red" повторяется 5 раз
```

```
[1] "red" "red" "red" "red" "red"
```

```r
rep(x = TRUE, times = 2) # TRUE повторяется 2 раза
```

```
[1] TRUE TRUE
```

В R названия аргументов функций можно не указывать, если вы используете аргументы в том же порядке, что прописан в help к этой функции.


```r
rep(TRUE, 5) # TRUE повторяется 5 раз, аргументы без названий
```

```
[1] TRUE TRUE TRUE TRUE TRUE
```

Создаем логический вектор, где TRUE повторяется 3 раза, FALSE 3 раза и TRUE 4 раза. Результат сохраняем в переменной vect_log


```r
vect_log &lt;- c(rep(TRUE, 3), rep(FALSE, 3), rep(TRUE, 4))
vect_log
```

```
 [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
```

### Применение логических векторов для фильтрации данных

Логические векторы создаются при проверке выполнения каких либо условий, заданных при помощи логических операторов (`&gt;`, `&lt;`, `==`, `!=`, `&gt;=`, `&lt;=`, `!`, `&amp;`, `|`). Такие векторы можно использовать для фильтрации данных

Вспомните, у нас был вот такой текстовый вектор


```r
double_rainbow
```

```
 [1] "red"    "orange" "yellow" "green"  "blue"   "violet" "red"    "orange" "yellow"
[10] "green"  "blue"   "violet"
```

Задача 1. Допустим, мы хотим из этого вектора извлечь только желтый цвет.

Мы можем создать логический вектор, в котором TRUE будет только для 3-го и 9-го элементов


```r
f_yellow &lt;- double_rainbow == "yellow"
f_yellow
```

```
 [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
```

Этот логический вектор-фильтр мы можем использовать для извлечения данных из `double_rainbow`


```r
double_rainbow[f_yellow]
```

```
[1] "yellow" "yellow"
```

Задача 2. Допустим, мы хотим извлечь из double_rainbow желтый и синий Желтый фильтр у нас уже есть, поэтому мы создадим фильтр для синего.


```r
f_blue &lt;- double_rainbow == "blue"
```

Выражение "желтый или синий" можно записать при помощи логического "или" (`|`)


```r
f_yellow | f_blue
```

```
 [1] FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE
```

Задача решена, мы извлекли желтый и синий цвета.


```r
double_rainbow[f_yellow | f_blue]
```

```
[1] "yellow" "blue"   "yellow" "blue"  
```

То же самое можно было бы записать короче.

В одну строку --- совершенно нечитабельно:


```r
double_rainbow[double_rainbow == "yellow" | double_rainbow == "blue"]
```

```
[1] "yellow" "blue"   "yellow" "blue"  
```

Фильтр отдельно --- читается лучше:


```r
f_colours &lt;- double_rainbow == "yellow" | double_rainbow == "blue"
double_rainbow[f_colours]
```

```
[1] "yellow" "blue"   "yellow" "blue"  
```

У нас был числовой вектор


```r
vect_num
```

```
 [1] -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7   8
[21]   9  10  11  12
```

Задача 3. Давайте извлечем из числового вектора `vect_num` только значения больше 0


```r
vect_num[vect_num &gt; 0]
```

```
 [1]  1  2  3  4  5  6  7  8  9 10 11 12
```

Задача 4. Давайте извлечем из вектора `vect_num` все числа, которые либо меньше или равны -8, либо больше или равны 8


```r
f_5_8 &lt;- (vect_num &lt;= -8) | (vect_num &gt;= 8)
vect_num[f_5_8]
```

```
[1] -11 -10  -9  -8   8   9  10  11  12
```

## Факторы

Факторы - это способ хранения дискретных (=категориальных данных). Например, если вы поймали 10 улиток и посмотрели их цвет. У большого количества улиток небольшое счетное количество возможных цветов.


```r
snail_colours &lt;- c("red", "green", "green", "green", "yellow", "yellow", "yellow", "yellow")
snail_colours # это текстовый вектор.
```

```
[1] "red"    "green"  "green"  "green"  "yellow" "yellow" "yellow" "yellow"
```

Но цвет "желтый" обозначает одно и то же для каждой из улиток. Поэтому в целях экономии места можно записать цвета этих улиток в виде вектора, в котором численным значениям будут сопоставлены "этикетки" (называются "уровни" - levels) - названия цветов. Мы можем создать "фактор" цвет улиток.


```r
factor(snail_colours)
```

```
[1] red    green  green  green  yellow yellow yellow yellow
Levels: green red yellow
```

уровни этого фактора

-   1 - green,
-   2 - red,
-   3 - yellow

По умолчанию, R назначает порядок уровней по алфавиту. Можно изменить порядок (см. `help("factor")`). Нам это пригодится позже


```r
double_rainbow # текстовый вектор
```

```
 [1] "red"    "orange" "yellow" "green"  "blue"   "violet" "red"    "orange" "yellow"
[10] "green"  "blue"   "violet"
```

Создаем фактор из текстового вектора и складываем его в переменную


```r
f_double_rainbow &lt;- factor(double_rainbow)
```

## Как узнать, что за данные хранятся в переменной?

Чтобы узнать, что за данные хранятся в переменной, используйте функцию `class()`


```r
class(f_double_rainbow)
```

```
[1] "factor"
```

```r
class(vect_log)
```

```
[1] "logical"
```

```r
class(vect_num)
```

```
[1] "integer"
```

```r
class(rainbow)
```

```
[1] "character"
```

# Встроенные константы в R

Встроенные константы в R: NA, NULL, NAN, Inf

-   NA - англ "not available". Когда объект был, но его свойство не измерили или не записали.
-   NULL - пусто - просто ничего нет
-   NaN - "not a number"
-   Inf - "infinity" - бесконечность

Вот текстовый вектор с пропущенным значением


```r
rainbow_1 &lt;- c("red", "orange", NA, "green", "blue", "violet")
```

Кстати, если попросили добыть из вектора номер элемента, которого там точно нет, то R выдаст NA, потому, что такого элемента нет


```r
rainbow_1[198]
```

```
[1] NA
```

Поэкспериментируем с векторами. Проверим, как работают арифметические операции


```r
vect_num + 2
```

```
 [1] -9 -8 -7 -6 -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14
```

```r
vect_num * 2
```

```
 [1] -22 -20 -18 -16 -14 -12 -10  -8  -6  -4  -2   0   2   4   6   8  10  12  14  16
[21]  18  20  22  24
```

```r
vect_num * (-2)
```

```
 [1]  22  20  18  16  14  12  10   8   6   4   2   0  -2  -4  -6  -8 -10 -12 -14 -16
[21] -18 -20 -22 -24
```

```r
vect_num ^2
```

```
 [1] 121 100  81  64  49  36  25  16   9   4   1   0   1   4   9  16  25  36  49  64
[21]  81 100 121 144
```

Теперь посмотрим на встроенные константы в действии.

Создаем новый вектор для экспериментов


```r
NAs_NANs &lt;- c(1, 3, NA, 7, 0, 22:24)
```

Вот так он выглядит


```r
NAs_NANs
```

```
[1]  1  3 NA  7  0 22 23 24
```

Что произойдет с NA?


```r
NAs_NANs + 2 # останется NA
```

```
[1]  3  5 NA  9  2 24 25 26
```

```r
NAs_NANs * 0 # останется NA
```

```
[1]  0  0 NA  0  0  0  0  0
```

```r
NAs_NANs / 0  # останется NA
```

```
[1] Inf Inf  NA Inf NaN Inf Inf Inf
```

Но в последнем случае вы увидите

-   Inf при делении чисел на ноль
-   NaN при делении нуля на ноль

NaN получится, если взять корень из отрицательного числа


```r
sqrt(-1)
```

```
[1] NaN
```

# Функции в R

Вы уже видели массу функций, их легко узнать по скобкам после ключевого слова. Познакомимся еще с несколькими и научимся писать пользовательские функции. Пользовательские функции позволяют автоматизировать повторяющиеся действия и делают код легко читаемым.

Вот наш вектор


```r
NAs_NANs
```

```
[1]  1  3 NA  7  0 22 23 24
```

Длину вектора можно вычислить при помощи функции `length()`


```r
length(NAs_NANs)
```

```
[1] 8
```

Сумму элементов вектора при помощи функции `sum()`


```r
sum(NAs_NANs)
```

```
[1] NA
```

Упс! Почему-то получилось `NA`

Чтобы узнать, почему и как это исправить - посмотрите в `help("sum")`. Выяснится, что у функции `sum()` есть аргумент `na.rm`, который по умолчанию принимает значение `FALSE`, то есть `NA` не учитываются при подсчете суммы.

Если мы передадим функции `sum` аргумент `na.rm = TRUE`, то получится правильная сумма


```r
sum(NAs_NANs, na.rm = TRUE)
```

```
[1] 80
```

Та же история с функцией `mean`


```r
mean(NAs_NANs, na.rm = TRUE)
```

```
[1] 11.43
```

Попробуем написать пользовательскую функцию `mmean()`, которая будет по умолчанию считать среднее значение элементов в векторе с учетом пропущенных значений (`NA`)


```r
mmean &lt;- function(x){
  mean(x, na.rm = TRUE)
  }
```

В этом коде: - mmean - переменная, название функции. В эту переменную мы складываем функцию, которую создает функция `function()` - `function()` - функция, которая делает функции. В скобках перечисляются аргументы (названия переменных, которые мы передаем в функцию, чтобы она что-то сделала с ними) - `{ }` - в фигурных скобках тело функции - последовательность действий, которую нужно сделать с аргументами

У больших функций бывает еще инструкция `return()`, которая сообщает, что именно должна возвращать наша функция. Вот как выглядела бы наша функция с этой инструкцией


```r
mmean &lt;- function(x){
  res &lt;- mean(x, na.rm = TRUE)
  return(res)
}
```

Проверим нашу функцию при помощи встроенной функции


```r
mean(vect_num, na.rm = TRUE)
```

```
[1] 0.5
```

```r
mmean(vect_num)
```

```
[1] 0.5
```

Работает

# Датафреймы - двумерные структуры данных

Датафрейм - один из способов хранения табличных данных в R. Создадим датафрейм.

Для этого, для начала, создадим векторы с данными для переменных.


```r
len &lt;- 1:9 # числовой
col &lt;- c(rep("green", 4), rep("red", 5)) # текстовый
wid &lt;- seq(from = 2, by = 2, to = 18) # числовой
```

Теперь сложим эти векторы в датафрейм


```r
my_worms &lt;- data.frame(Length = len, Width = wid, Colour = col)
```

Можно проверить, действительно мы создали объект класса data.frame


```r
class(my_worms) # смотрим, действительно датафрейм
```

```
[1] "data.frame"
```

Содержимое датафрейма можно просмотреть несколькими способами


```r
my_worms # печать датафрейма
```

```
  Length Width Colour
1      1     2  green
2      2     4  green
3      3     6  green
4      4     8  green
5      5    10    red
6      6    12    red
7      7    14    red
8      8    16    red
9      9    18    red
```

```r
View(my_worms) # просмотр в RStudio
head(my_worms)
```

```
  Length Width Colour
1      1     2  green
2      2     4  green
3      3     6  green
4      4     8  green
5      5    10    red
6      6    12    red
```

```r
tail(my_worms)
```

```
  Length Width Colour
4      4     8  green
5      5    10    red
6      6    12    red
7      7    14    red
8      8    16    red
9      9    18    red
```

```r
# fix(my_worms) # ручное редактирование. осторожно! избегайте его использовать, никаких документов о нем не останется
```

## Адресация внутри датафреймов

Вывод столбца-переменной при помощи оператора \$ и имени переменной


```r
my_worms$Length
```

```
[1] 1 2 3 4 5 6 7 8 9
```

```r
my_worms$Width
```

```
[1]  2  4  6  8 10 12 14 16 18
```

У каждой ячейки в датафрейме есть координаты вида [строка, столбец]


```r
my_worms[2, 3] # вторая строка в 3 столбце
```

```
[1] "green"
```

```r
my_worms[2, ] # вторая строка целиком
```

```
  Length Width Colour
2      2     4  green
```

```r
my_worms[1:9, 2] # строки с 1 по 9 во втором столбце
```

```
[1]  2  4  6  8 10 12 14 16 18
```

```r
my_worms[, 2] # второй столбец целиком
```

```
[1]  2  4  6  8 10 12 14 16 18
```

# Визуализация данных

## Базовые графики

Скаттерплот (точечный график) --- по оси х и y непрерывные числовые величины


```r
plot(x = my_worms$Width, y = my_worms$Length)
```

![](01_intro_xaringan_files/figure-html/p-scatter-1.png)&lt;!-- --&gt;

Боксплот --- по оси х дискретная величина, по оси y значение непрерывной величины. Черта - медиана, коробка - 25 и 75 перцентили, усы - либо размах варьирования, либо 1.5 интерквартильных расстояния (1.5 высоты коробки), если есть "выбросы".


```r
plot(x = as.factor(my_worms$Colour), y = my_worms$Length)
```

![](01_intro_xaringan_files/figure-html/p-box-1.png)&lt;!-- --&gt;

Для настройки внешнего вида см graphical parameters в help

На самом деле, мы не будем пользоваться этой системой графики, но об этом в следующих сериях

## Графики из пакета ggplot2

В R есть более удобный (но, может быть, более многословный) пакет для рисования графиков --- ggplot2. Чтобы использовать функции из пакета ggplot2, нужно его сначала установить.

Установка пакета в локальную библиотеку делается один раз. Поэтому строку с `install.packages()` не нужно включать в финальную версию кода.


```r
install.packages('ggplot2')
```

В текущей сессии работы в R пакет нужно активировать перед использованием. Когда вы в следующий раз начнете работать с R, нужные пакеты придется снова активировать. Поэтому строки с загрузкой пакетов при помощи `library()` обязательно должны остаться в финальной версии кода.


```r
library(ggplot2)
```

Нарисуем те же самые графики при помощи пакета ggplot2.


```r
ggplot(data = my_worms) +
  geom_point(aes(x = Width, y = Length))
```

![](01_intro_xaringan_files/figure-html/gg-scatter-box-1.png)&lt;!-- --&gt;

```r
ggplot(data = my_worms) +
  geom_boxplot(aes(x = Colour, y = Length))
```

![](01_intro_xaringan_files/figure-html/gg-scatter-box-2.png)&lt;!-- --&gt;

Добавляем для точек эстетику цвет (colour) из переменной Colour


```r
ggplot(data = my_worms) +
  geom_point(aes(x = Width, y = Length, colour = Colour))
```

![](01_intro_xaringan_files/figure-html/gg-colour-1.png)&lt;!-- --&gt;

Графики можно сохранять в переменных, и использовать потом


```r
gg &lt;- ggplot(data = my_worms) +
  geom_point(aes(x = Width, y = Length, colour = Colour))
```

Чтобы вывести график, нужно напечатать название переменной.


```r
gg
```

![](01_intro_xaringan_files/figure-html/gg-saved-1.png)&lt;!-- --&gt;

Можно менять темы оформления графика. Если тема нужна только один раз, то прибавляем ее к графику


```r
gg + theme_dark()
```

![](01_intro_xaringan_files/figure-html/gg-themes-1.png)&lt;!-- --&gt;

```r
gg + theme_light()
```

![](01_intro_xaringan_files/figure-html/gg-themes-2.png)&lt;!-- --&gt;

```r
gg + theme_classic()
```

![](01_intro_xaringan_files/figure-html/gg-themes-3.png)&lt;!-- --&gt;

Можно установить нужную тему до конца сессии.


```r
theme_set(theme_bw())
gg
```

![](01_intro_xaringan_files/figure-html/gg-theme-set-1.png)&lt;!-- --&gt;

Подписи осей и легенд задает функция labs()


```r
gg + labs(x = "Ширина", y = "Длина", colour = "Цвет")
```

![](01_intro_xaringan_files/figure-html/gg-labs-1.png)&lt;!-- --&gt;

Графики можно делить на фасетки при помощи facet_wrap или facet_grid


```r
gg + facet_wrap(~Colour, nrow = 1)
```

![](01_intro_xaringan_files/figure-html/gg-facets-1.png)&lt;!-- --&gt;

Чтобы изменить подписи цветов, нужно изменить уровни соотв. фактора.


```r
my_worms$col_rus &lt;- factor(my_worms$Colour, levels = c("green", "red"), labels = c("Зеленый", "Красный"))
ggplot(data = my_worms) +
  geom_point(aes(x = Width, y = Length, colour = col_rus)) +
  labs(x = "Ширина", y = "Длина", colour = "Цвет") +
  facet_wrap(~col_rus, nrow = 1)
```

![](01_intro_xaringan_files/figure-html/gg-translate-captions-1.png)&lt;!-- --&gt;

---

## Настройка RStudio

Все настройки RStudio находятся в меню Tools -\&gt; Global Options

-   Восстановление рабочего пространства из прошлого сеанса --- это лучше отменить, т.к. обычно переменные-призраки очень мешают. На вкладке `General` убираем галочку `Restore .RData into workspace at startup`, и меняем `Save workspace to .RData on exit` на `Never`
-   Перенос длинных строк в окне кода --- это удобно. На вкладке `Code` ставим галочку рядом с опцией `Soft-wrap R source files`.

### Комментарии

Комментарии в текстах программ обозначаются символом \#


```r
# это комментарии, они не будут выполняться
```

---

### Полезные клавиатурные сокращения в RStudio

-   `Ctrl + Shift + C` --- закомментировать/раскомментировать выделенный фрагмент кода.
-   `Ctrl + Enter` --- отправляет активную строку из текстового редактора в консоль, а если выделить несколько строк, то будет выполнен этот фрагмент кода.
-   `Ctrl + Alt` --- выбор нескольких строк одновременно.
-   `Tab` или `Ctrl + Space` --- нажмите после того как начали набирать название функции или переменной, и появится список автоподстановки. Это помогает печатать код быстро и с меньшим количеством ошибок.
-   `Ctrl + L` --- очистить консоль. 
-   `Alt + -` --- ввод оператора присваивания (`&lt;-`).
-   `Ctrl + Shift + M` --- ввод оператора `%&gt;%` (pipe operator).

---

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="assets/macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "vs",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<!-- https://github.com/fnaufel/xaringan-smartify-->
<script type="text/javascript">
  smartify();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
